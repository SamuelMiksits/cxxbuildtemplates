# Introduction

This repo contains build templates for use in Visual Studio code, particularly with C/C++ building/debugging, with the C/C++ extension. However, it also contains templates/commonly used blocks for CMake, should you find that interesting. 

# ```tasks.json```


## g++
The default configuration for ```tasks.json``` gets generated by the debugger. It gets generated when you press ```Run->Start Debugging (F5)``` while hovering over a C/C++ file (```main.c``` or ```main.cpp``` or any file with those extensions really):

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++ build active file",
            "command": "/usr/bin/g++",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```
Note that this configuration assumes linux, for more information, check out [Debug C++ in Visual Studio Code](https://code.visualstudio.com/docs/cpp/cpp-debug). The path for ```command``` might have to be changed to ```C:\\MinGw\\bin\\g++.exe``` or something else on Windows depending on what compiler you want to use it with and how you installed it.


In ```args``` you can specify other files and compiler flags, example below if you for instance need the libraries ```A.cpp```, ```B.cpp``` and ```C.cpp```, and have an external library ```/path/to/external/library.a``` that requires an include directory with ```-I /path/to/external/includes```:

```json
"args": [
    "-fdiagnostics-color=always",
    "-g",
    "${file}",
    "A.cpp",
    "B.cpp",
    "C.cpp",
    "/path/to/external/library.a",
    "-I",
    "path/to/external/includes",
    "-o",
    "${fileDirname}/${fileBasenameNoExtension}"
],
```

Another important part of the ```tasks.json``` file is the following section:

```json
"group": {
    "kind": "build",
    "isDefault": true
},
```

If you add these properties, it means that you flag your task as a build task, and enable it by default. In practice, this means that you can use to ```Terminal->Run Build Task...```, which can also be activated with ```Ctrl+Shift+B```, to instantly run only the build task assigned with the ```"isDefault": true``` property, without a launch, which we will get to later.

## CMake
The approach above is fine, but if you get into larger projects it is advisable to create a CMake/Makefile build script, as the command above peforms single-threaded compilation of all files, regardless if anything has changed since last compile. CMake/Makefile can fix both of thes problems.

```"type"``` needs to be changed to ```"shell"```, as otherwise VSCode will try to look for a program named "cmake .. && make" for example instead of running those as shell commands. CMake based build template:


```json
{
    "tasks": [
        {
            "type": "shell",
            "label": "C/C++: CMake build active file",
            "command": "mkdir -p ${fileDirname}/build && cd ${fileDirname}/build && cmake .. && make -j $(nproc)",
            "args": [],
            "options": {
                "cwd": "${fileDirname}"
            },
            "detail": "CMake build"
        }
    ],
    "version": "2.0.0"
}
```

- ```mkdir -p``` creates the directory only if it does not already exists.
- ```make -j $(nproc)``` uses all available threads on the system to schedule parallel jobs.

Though you need to configure a CMakeLists.txt, instructions can be found below.

If you have testing, you may also want to change your "command" option to:

```json
"command": "mkdir -p ${fileDirname}/build && cd ${fileDirname}/build && cmake .. && make -j $(nproc) && make test",
```

or you could put testing as a separate task.



# ```launch.json```

If you just pressed F5 on a file called ```main.cpp```, it generates a ```tasks.json``` file, but it uses a "shadow" ```launch.json``` file which launches the output file with the debugger, and then it performs a ```preLaunchTask``` that builds the program (which is the default task in the ```tasks.json``` file). This ```launch.json``` file roughly matches the default behaviour of the debugger:

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "C++ Launch",
            "type": "cppdbg",
            "request": "launch",
            "program": "${fileDirname}/${fileBasenameNoExtension}",
            "args": [],
            "environment": [{ "name": "config", "value": "Debug" }],
            "cwd": "${fileDirname}",
            "linux": {
                "MIMode": "gdb",
                "miDebuggerPath": "/usr/bin/gdb"
            },
            "preLaunchTask": "C/C++: g++ build active file",
        }
    ]
}
```
Note that this configuration assumes linux, for more information, check out [Debug C++ in Visual Studio Code](https://code.visualstudio.com/docs/cpp/cpp-debug). The configuration:

```json
"linux": {
    "MIMode": "gdb",
    "miDebuggerPath": "/usr/bin/gdb"
},
```

would need to be:

```json
"windows": {
    "MIMode": "gdb",
    "miDebuggerPath": "C:\\MinGw\\bin\\gdb.exe"
  }
```

on Windows for instance, depending on what debugger you are planning to use and its location. A configuration for Mac can be created in a similar fashion with ```"osx"```.

Note that you can use the ```"args": []``` if the program you are trying to debug requires command line options.

If you instead opted for the CMake approach, you might need to change the line
```json
    "preLaunchTask": "C/C++: g++ build active file"
```

to whatever you named your build task.

Do note that you need to accomodate your build task's launch path. The g++ approach will create a file called ```main``` in the base directory if you compiled a file called ```main.cpp```, but with CMake it will place the file in a build subdirectory. Change the ```program``` variable from:

```json
"program": "${fileDirname}/${fileBasenameNoExtension}"
```

to

```json
"program": "${fileDirname}/build/${fileBasenameNoExtension}"
```

# ```CMakeLists.txt```

This is not a full CMake tutorial, but contains commonly used blocks of CMake and what they mean in terms of gcc syntax:

## Start

You should at least state the ```cmake_minimum_required```, set ```CMAKE_CXX_STANDARD``` variable and have a ```project``` statement in all of your CMakeLists.txt files:

```cmake

cmake_minimum_required(VERSION 3.11) # picked version 3.11 because that's when
                                     # FetchContent was added, make sure
                                     # that all the functions you rely on
                                     # exist in the version you pick

set(CMAKE_CXX_STANDARD 17)
# above is equal to:
# g++ ... -std=c++17
# Pick an older standard unless you have a specific reason,
# are you really using concepts and [[assume]]?

# Set project name, the value gets stored in the variable
# CMAKE_PROJECT_NAME
project(cxxbuildtemplates)
```

Note that if you are using C++ and C, or just C, you should also include a line with 

```cmake 
set(CMAKE_C_STANDARD)
```

## Executables

If you want to compile a C++ file you would do the following:

```bash
g++ main.cpp -o main
```

and in order to do the same in CMake you would need to write:

```cmake
add_executable(main main.cpp)
```

## Linking files

If you want to compile a C++ main file together with some other implementations you would do the following:

```bash
g++ main.cpp A.cpp B.cpp C.cpp -o main
```

and in order to do the same in CMake you would need to write:

```cmake
# This corresponds roughly to:
# g++ -c A.cpp -o A.o
# g++ -c B.cpp -o B.o
# g++ -c C.cpp -o C.o
# and combining it into one file
add_library(ABC A.cpp B.cpp C.cpp)
# The actual file for "ABC" gets named libABC.a by CMake when compiled

add_executable(main main.cpp) #Compile the main file

# link library, corresponds to
# g++ main.cpp libABC.a -o main
target_link_libraries(main ABC)

```

## Include directories

If you want to perform

```bash
g++ main.cpp /path/to/external/library.a -I /path/to/external/includes
```

it would be expressed as:

```cmake
include_directories(/path/to/external/includes)
target_link_libraries(main /path/to/external/library.a)
```


## Compile flags

If you want to enable the ```-g``` option for the above example that has the library ```ABC``` and a main file ```main.cpp``` you would need to do the following:

```cmake
# Both must have this option if you want to be able to place
# breakpoints in vscode and use debugging 
target_compile_options(main PRIVATE -g)
target_compile_options(ABC PRIVATE -g)
```

## Subdirectories

If you have a root directory, which builds several subdirectories, place a ```CMakeLists.txt``` file in the root directory. Then place a ```CMakeLists.txt``` file in each of the subdirectories. The root ```CMakeLists.txt``` should have the:
- ```cmake_minimum_required```
- set ```CMAKE_CXX_STANDARD``` and or ```CMAKE_C_STANDARD```
- ```project()```

Then use the ```add_subdirectory``` command to pass over the responsibility of building the subfolders to the subfolder's ```CMakeLists.txt``` directives. 

Example: If you have a root folder, with the subfolders ```A```, ```B```, ```C```. Each of the subfolders have a file called ```main.cpp```, the following configuration could be used:

Root folder ```CMakeLists.txt```:

```cmake
cmake_minimum_required(VERSION 3.11) 
set(CMAKE_CXX_STANDARD 17)
project(cxxbuildtemplates)

add_subdirectory(A)
add_subdirectory(B)
add_subdirectory(C)
```

And then subfolder A's ```CMakeLists.txt``` only needs to add the executable file, since the ```CMakeLists.txt``` will follow properties specified in the root folder:

```cmake
add_executable(main_A main.cpp)
```
Same would be done for the other subfolders. Do note the "mangling" of the name, as having all files be named "main" is disallowed, or multiple targets sharing name in general, even if they do not share the same output folder.

The resulting output files would then be ```/build_directory/A/main_A```, ```/build_directory/B/main_B``` and ```/build_directory/C/main_C```. Though if you want this to be different, ```add_subdirectory``` allows you to pass an optional ```binary_dir``` path to the command.

## CxxTest

The method below adds support for CxxTest in your project. ```enable_testing()``` add the makefile target ```make test``` which will run all the added tests (add as many tests as you want with the CXXTEST_ADD_TEST command).

The template assumes that you are testing some sort of library/API

```cmake
# creates file "libABC.a"
add_library(ABC A.cpp B.cpp C.cpp)

# search for cxxtest on the system,
# user may have already installed 
# it with a package manager
find_package(CxxTest)
# result gets stored in variable CXXTEST_FOUND

# if not found, download from git
if (NOT CXXTEST_FOUND)
    include(FetchContent)
    FetchContent_Declare(
    cxxtest
        GIT_REPOSITORY https://github.com/CxxTest/cxxtest.git
    )
    FetchContent_MakeAvailable(cxxtest)
    set(CXXTEST_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/build/_deps/cxxtest-src/bin)
    find_package(CxxTest REQUIRED) #run it again, 
    # it screws up build cache variables 
    # if it is never properly found
endif()

include_directories(${CXXTEST_INCLUDE_DIR}/../)
enable_testing()

# below assumes your CxxTest is written in a file named mytest.h
CXXTEST_ADD_TEST(mytest mytest.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/mytest.h)
target_link_libraries(mytest ABC)
```
